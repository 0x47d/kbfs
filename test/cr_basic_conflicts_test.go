// Copyright 2016 Keybase Inc. All rights reserved.
// Use of this source code is governed by a BSD
// license that can be found in the LICENSE file.

// These tests all do multiple operations while a user is unstaged.

package test

import (
	"runtime"
	"testing"
)

// bob and alice both write(to the same file),
func TestCrConflictWriteFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkfile("a/b", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "world"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
	)
}

// bob and alice both create the same file
func TestCrConflictCreateFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "world"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
	)
}

// bob creates a directory with the same name that alice used for a file
func TestCrConflictCauseRenameOfMergedFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "world"),
		),
		as(bob, noSync(),
			write("a/b/c", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "world"),
			read("a/b/c", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "world"),
			read("a/b/c", "uh oh"),
		),
	)
}

// bob creates a directory with the same name that alice used for a
// file that used to exist at that location
func TestCrConflictCauseRenameOfMergedRecreatedFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
			write("a/b", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "world"),
		),
		as(bob, noSync(),
			rm("a/b"),
			write("a/b/c", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "world"),
			read("a/b/c", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "world"),
			read("a/b/c", "uh oh"),
		),
	)
}

// bob renames a file over one modified by alice.
func TestCrConflictUnmergedRenameFileOverModifiedFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "uh oh"),
		),
		as(bob, noSync(),
			rename("a/c", "a/b"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "world"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "world"),
		),
	)
}

// bob renames a file from a new directory over one modified by alice.
func TestCrConflictUnmergedRenameFileInNewDirOverModifiedFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "uh oh"),
		),
		as(bob, noSync(),
			rename("a/c", "e/c"),
			rename("e/c", "a/b"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			lsdir("e/", m{}),
			read("a/b", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "world"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			lsdir("e/", m{}),
			read("a/b", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "world"),
		),
	)
}

// bob renames a directory over a file modified by alice.
func TestCrConflictUnmergedRenameDirOverModifiedFile(t *testing.T) {
	if realFS && runtime.GOOS == "linux" {
		t.Skip("Renaming directories over files not supported on linux fuse (ENOTDIR)")
	}
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			write("a/c/d", "world"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "uh oh"),
		),
		as(bob, noSync(),
			rename("a/c", "a/b"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b/d", "world"),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b/d", "world"),
			read("a/b.conflict.alice.0001-01-01T00:00:00Z", "uh oh"),
		),
	)
}

// bob renames an existing directory over one created by alice.
// TODO: it would be better if this weren't a conflict.
func TestCrConflictUnmergedRenamedDir(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/d/e", "world"),
		),
		as(bob, noSync(),
			write("a/b/f", "uh oh"),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z", m{"c": "FILE", "f": "FILE"}),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/c", "hello"),
			read("a/d/e", "world"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/f", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z", m{"c": "FILE", "f": "FILE"}),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/c", "hello"),
			read("a/d/e", "world"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/f", "uh oh"),
		),
	)
}

// alice renames an existing directory over one created by bob. TODO:
// it would be better if this weren't a conflict.
func TestCrConflictMergedRenamedDir(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b/f", "uh oh"),
			rename("a/b", "a/d"),
		),
		as(bob, noSync(),
			write("a/d/e", "world"),
			reenableUpdates(),
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"c": "FILE", "f": "FILE"}),
			read("a/d/c", "hello"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/e", "world"),
			read("a/d/f", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"c": "FILE", "f": "FILE"}),
			read("a/d/c", "hello"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/e", "world"),
			read("a/d/f", "uh oh"),
		),
	)
}

// alice renames a file over one modified by bob.
func TestCrConflictMergedRenameFileOverModifiedFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/c", "a/b"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
	)
}

// alice renames a directory over a file modified by bob.
func TestCrConflictMergedRenameDirOverModifiedFile(t *testing.T) {
	if realFS && runtime.GOOS == "linux" {
		t.Skip("Renaming directories over files not supported on linux fuse (ENOTDIR)")
	}
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			write("a/c/d", "world"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/c", "a/b"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b/d", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b/d", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
	)
}

// alice and both both rename(the same file, causing a copy.),
func TestCrConflictRenameSameFile(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b", "a/c"),
		),
		as(bob, noSync(),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"c": "FILE", "d": "FILE"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
		),
		as(alice,
			lsdir("a/", m{"c": "FILE", "d": "FILE"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			read("a/c", "world"),
			read("a/d", "hello"),
		),
	)
}

// alice and both both rename(the same executable file, causing a copy.),
func TestCrConflictRenameSameEx(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b", "hello"),
			setex("a/b", true),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b", "a/c"),
		),
		as(bob, noSync(),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"c": "EXEC", "d": "EXEC"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
		),
		as(alice,
			lsdir("a/", m{"c": "EXEC", "d": "EXEC"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			read("a/c", "world"),
			read("a/d", "hello"),
		),
	)
}

// alice and both both rename(the same symlink.),
func TestCrConflictRenameSameSymlink(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/foo", "hello"),
			link("a/b", "foo"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b", "a/c"),
		),
		as(bob, noSync(),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"foo": "FILE", "c": "SYM", "d": "SYM"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
		),
		as(alice,
			lsdir("a/", m{"foo": "FILE", "c": "SYM", "d": "SYM"}),
			read("a/c", "hello"),
			read("a/d", "hello"),
			write("a/c", "world"),
		),
		as(bob,
			read("a/c", "world"),
			read("a/d", "world"),
		),
	)
}

// alice and bob both rename(the same directory, causing a symlink to),
// be created.
func TestCrConflictRenameSameDir(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b", "a/d"),
		),
		as(bob, noSync(),
			rename("a/b", "a/e"),
			reenableUpdates(),
			lsdir("a/", m{"d": "DIR", "e": "SYM"}),
			read("a/d/c", "hello"),
			read("a/e/c", "hello"),
		),
		as(alice,
			lsdir("a/", m{"d": "DIR", "e": "SYM"}),
			read("a/d/c", "hello"),
			read("a/e/c", "hello"),
			write("a/d/f", "world"),
			read("a/e/f", "world"),
		),
		as(bob,
			read("a/e/f", "world"),
		),
	)
}

// alice and bob both rename(the same directory, causing a symlink to),
// be created.
func TestCrConflictRenameSameDirUpward(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c/d/e/foo", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b/c/d/e", "a/e"),
		),
		as(bob, noSync(),
			rename("a/b/c/d/e", "a/b/c/d/f"),
			reenableUpdates(),
			lsdir("a/", m{"b": "DIR", "e": "DIR"}),
			lsdir("a/e", m{"foo": "FILE"}),
			lsdir("a/b/c/d", m{"f": "SYM"}),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			read("a/e/foo", "hello"),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
		),
		as(alice,
			lsdir("a/", m{"b": "DIR", "e": "DIR"}),
			lsdir("a/e", m{"foo": "FILE"}),
			lsdir("a/b/c/d", m{"f": "SYM"}),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			read("a/e/foo", "hello"),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			write("a/e/foo2", "world"),
		),
		as(bob,
			read("a/b/c/d/f/foo2", "world"),
		),
	)
}

// alice and bob both rename(the same directory, causing a symlink to),
// be created.
func TestCrConflictRenameSameDirMergedUpward(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c/d/e/foo", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b/c/d/e", "a/b/c/d/f"),
		),
		as(bob, noSync(),
			rename("a/b/c/d/e", "a/e"),
			reenableUpdates(),
			lsdir("a/", m{"b": "DIR", "e": "SYM"}),
			lsdir("a/e", m{"foo": "FILE"}),
			lsdir("a/b/c/d", m{"f": "DIR"}),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			read("a/e/foo", "hello"),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
		),
		as(alice,
			lsdir("a/", m{"b": "DIR", "e": "SYM"}),
			lsdir("a/e", m{"foo": "FILE"}),
			lsdir("a/b/c/d", m{"f": "DIR"}),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			read("a/e/foo", "hello"),
			lsdir("a/b/c/d/f", m{"foo": "FILE"}),
			write("a/e/foo2", "world"),
		),
		as(bob,
			read("a/b/c/d/f/foo2", "world"),
		),
	)
}

func TestCrConflictRenameSameDirDownward(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/foo", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b", "a/c/d/e/f"),
		),
		as(bob, noSync(),
			rename("a/b", "a/g"),
			reenableUpdates(),
			lsdir("a/", m{"c": "DIR", "g": "SYM"}),
			lsdir("a/c/d/e/f", m{"foo": "FILE"}),
			lsdir("a/g", m{"foo": "FILE"}),
			read("a/c/d/e/f/foo", "hello"),
			read("a/g/foo", "hello"),
		),
		as(alice,
			lsdir("a/", m{"c": "DIR", "g": "SYM"}),
			lsdir("a/c/d/e/f", m{"foo": "FILE"}),
			lsdir("a/g", m{"foo": "FILE"}),
			read("a/c/d/e/f/foo", "hello"),
			read("a/g/foo", "hello"),
			write("a/c/d/e/f/foo2", "world"),
		),
		as(bob,
			read("a/g/foo2", "world"),
		),
	)
}

func TestCrConflictRenameSameDirSideways(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c/d/foo", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/b/c/d", "a/e/f/g"),
		),
		as(bob, noSync(),
			rename("a/b/c/d", "a/b/c/h"),
			reenableUpdates(),
			lsdir("a/e/f", m{"g": "DIR"}),
			lsdir("a/b/c", m{"h": "SYM"}),
			lsdir("a/e/f/g", m{"foo": "FILE"}),
			lsdir("a/b/c/h", m{"foo": "FILE"}),
			read("a/e/f/g/foo", "hello"),
			read("a/b/c/h/foo", "hello"),
		),
		as(alice,
			lsdir("a/e/f", m{"g": "DIR"}),
			lsdir("a/b/c", m{"h": "SYM"}),
			lsdir("a/e/f/g", m{"foo": "FILE"}),
			lsdir("a/b/c/h", m{"foo": "FILE"}),
			read("a/e/f/g/foo", "hello"),
			read("a/b/c/h/foo", "hello"),
			write("a/e/f/g/foo2", "world"),
		),
		as(bob,
			read("a/b/c/h/foo2", "world"),
		),
	)
}

// bob renames an existing directory over one created by alice, twice.
// TODO: it would be better if this weren't a conflict.
func TestCrConflictUnmergedRenamedDirDouble(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			write("a/b/c", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/d/e", "world"),
		),
		as(bob, noSync(),
			write("a/b/f", "uh oh"),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z", m{"c": "FILE", "f": "FILE"}),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/c", "hello"),
			read("a/d/e", "world"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/f", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z", m{"c": "FILE", "f": "FILE"}),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/c", "hello"),
			read("a/d/e", "world"),
			read("a/d.conflict.bob.0001-01-01T00:00:00Z/f", "uh oh"),
			rm("a/d/e"),
			rm("a/d"),
			write("a/b/c", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/d/e", "world"),
		),
		as(bob, noSync(),
			write("a/b/f", "uh oh"),
			rename("a/b", "a/d"),
			reenableUpdates(),
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z_\\(1\\)": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z_(1)", m{"c": "FILE", "f": "FILE"}),
			read("a/d/e", "world"),
		),
		as(alice,
			lsdir("a/", m{"d$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z$": "DIR", "d.conflict.bob.0001-01-01T00:00:00Z_\\(1\\)": "DIR"}),
			lsdir("a/d", m{"e": "FILE"}),
			lsdir("a/d.conflict.bob.0001-01-01T00:00:00Z_(1)", m{"c": "FILE", "f": "FILE"}),
			read("a/d/e", "world"),
		),
	)
}

// bob and alice both write(to the same file),
func TestCrConflictWriteFileDouble(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkfile("a/b", "hello"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "world"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b", "world"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			write("a/b", "another write"),
		),
		as(bob, noSync(),
			write("a/b", "uh oh again!"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z_\\(1\\)": "FILE"}),
			read("a/b", "another write"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z_(1)", "uh oh again!"),
		),
		as(alice,
			lsdir("a/", m{"b$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z$": "FILE", "b.conflict.bob.0001-01-01T00:00:00Z_\\(1\\)": "FILE"}),
			read("a/b", "another write"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z_(1)", "uh oh again!"),
		),
	)
}

// bob causes a rename(cycle with a conflict while unstaged),
func TestCrRenameCycleWithConflict(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
			mkdir("a/b"),
			mkdir("a/c"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/c", "a/b/c"),
		),
		as(bob, noSync(),
			rename("a/b", "a/c/b"),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b": "SYM"}),
			lsdir("a/b/c/b", m{"c": "DIR"}),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b": "SYM"}),
			lsdir("a/b/c/b", m{"c": "DIR"}),
			write("a/b/d", "hello"),
		),
		as(bob,
			read("a/b/c/b/d", "hello"),
		),
	)
}

// bob causes a rename(cycle with two conflicts while unstaged),
func TestCrRenameCycleWithTwoConflicts(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
			mkdir("a/b"),
			mkdir("a/c"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/c", "a/b/c"),
			write("a/b/c/b", "uh oh"),
		),
		as(bob, noSync(),
			rename("a/b", "a/c/b"),
			write("a/b", "double uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "double uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b$": "SYM", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			lsdir("a/b/c/b", m{"c": "DIR"}),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "double uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b$": "SYM", "b.conflict.alice.0001-01-01T00:00:00Z": "FILE"}),
			lsdir("a/b/c/b", m{"c": "DIR"}),
			write("a/b/d", "hello"),
		),
		as(bob,
			read("a/b/c/b/d", "hello"),
		),
	)
}

// bob causes a rename(cycle with two conflicts while unstaged),
func TestCrRenameCycleWithConflictAndMergedDir(t *testing.T) {
	test(t,
		writers("alice", "bob"),
		as(alice,
			mkdir("a"),
			mkdir("a/b"),
			mkdir("a/c"),
		),
		as(bob,
			disableUpdates(),
		),
		as(alice,
			rename("a/c", "a/b/c"),
			mkdir("a/b/c/b"),
		),
		as(bob, noSync(),
			rename("a/b", "a/c/b"),
			write("a/b", "uh oh"),
			reenableUpdates(),
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "SYM"}),
			lsdir("a/b/c/b.conflict.bob.0001-01-01T00:00:00Z", m{"c": "DIR"}),
			lsdir("a/b/c/b", m{}),
		),
		as(alice,
			lsdir("a/", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "FILE"}),
			read("a/b.conflict.bob.0001-01-01T00:00:00Z", "uh oh"),
			lsdir("a/b/", m{"c": "DIR"}),
			lsdir("a/b/c", m{"b$": "DIR", "b.conflict.bob.0001-01-01T00:00:00Z": "SYM"}),
			lsdir("a/b/c/b.conflict.bob.0001-01-01T00:00:00Z", m{"c": "DIR"}),
			lsdir("a/b/c/b", m{}),
			write("a/b/d", "hello"),
		),
		as(bob,
			read("a/b/c/b.conflict.bob.0001-01-01T00:00:00Z/d", "hello"),
		),
	)
}
